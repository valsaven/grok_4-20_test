<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Frontend Tech Demo</title>
    <style>
      /* --- CORE VARIABLES & RESET --- */
      :root {
        /* Dynamic Theme Variables */
        --hue: 180; /* Default Cyan */
        --primary: hsl(var(--hue), 100%, 50%);
        --primary-dim: hsla(var(--hue), 100%, 50%, 0.1);
        --primary-glow: hsla(var(--hue), 100%, 50%, 0.5);

        --bg-dark: #050505;
        --bg-panel: #0a0a0a;
        --text-main: #e0e0e0;
        --font-mono: "Courier New", Courier, monospace;
        --font-display: system-ui, -apple-system, sans-serif;

        --card-glass: rgba(255, 255, 255, 0.03);
        --card-border: rgba(255, 255, 255, 0.1);
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        background-color: var(--bg-dark);
        color: var(--text-main);
        font-family: var(--font-display);
        overflow-x: hidden;
        scroll-behavior: smooth;
      }

      section {
        min-height: 100vh;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-bottom: 1px solid #222;
        padding: 2rem;
        overflow: hidden;
      }

      h2 {
        font-family: var(--font-mono);
        text-transform: uppercase;
        letter-spacing: 4px;
        margin-bottom: 2rem;
        color: var(--primary);
        text-shadow: 0 0 10px var(--primary-glow);
        z-index: 10;
        font-size: clamp(1.5rem, 5vw, 3rem);
        text-align: center;
      }

      /* --- DEMO 1: CYBERPUNK HUD --- */
      #demo-hud {
        background:
          linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
          linear-gradient(
            90deg,
            rgba(255, 0, 0, 0.06),
            rgba(0, 255, 0, 0.02),
            rgba(0, 0, 255, 0.06)
          );
        background-size:
          100% 2px,
          3px 100%;
      }

      .hud-container {
        position: relative;
        width: clamp(300px, 80vw, 800px);
        padding: 2rem;
        border: 1px solid var(--primary-dim);
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(5px);
        box-shadow: 0 0 20px var(--primary-dim);
      }

      /* Holographic Corners */
      .hud-container::before,
      .hud-container::after {
        content: "";
        position: absolute;
        width: 20px;
        height: 20px;
        border: 2px solid var(--primary);
        transition: all 0.3s ease;
      }
      .hud-container::before {
        top: -2px;
        left: -2px;
        border-right: none;
        border-bottom: none;
      }
      .hud-container::after {
        bottom: -2px;
        right: -2px;
        border-left: none;
        border-top: none;
      }

      .glitch-text {
        font-family: var(--font-mono);
        font-weight: bold;
        font-size: clamp(2rem, 6vw, 4rem);
        position: relative;
        color: #fff;
        mix-blend-mode: lighten;
      }

      .glitch-text::before,
      .glitch-text::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        width: 100%;
        background: var(--bg-dark);
        clip: rect(0, 0, 0, 0);
      }

      .glitch-text::before {
        left: -2px;
        text-shadow: 2px 0 #ff00c1;
        animation: glitch-anim-1 2s infinite linear alternate-reverse;
      }

      .glitch-text::after {
        left: 2px;
        text-shadow: -2px 0 #00fff9;
        animation: glitch-anim-2 3s infinite linear alternate-reverse;
      }

      .scan-line {
        width: 100%;
        height: 5px;
        background: var(--primary);
        opacity: 0.5;
        position: absolute;
        top: 0;
        left: 0;
        animation: scan 3s linear infinite;
        box-shadow: 0 0 10px var(--primary);
      }

      .hud-stats {
        display: flex;
        justify-content: space-between;
        margin-top: 2rem;
        font-family: var(--font-mono);
        font-size: 0.8rem;
      }

      @keyframes scan {
        0% {
          top: 0%;
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        90% {
          opacity: 1;
        }
        100% {
          top: 100%;
          opacity: 0;
        }
      }

      @keyframes glitch-anim-1 {
        0% {
          clip: rect(20px, 9999px, 10px, 0);
        }
        20% {
          clip: rect(70px, 9999px, 80px, 0);
        }
        40% {
          clip: rect(30px, 9999px, 10px, 0);
        }
        60% {
          clip: rect(50px, 9999px, 20px, 0);
        }
        80% {
          clip: rect(10px, 9999px, 60px, 0);
        }
        100% {
          clip: rect(90px, 9999px, 40px, 0);
        }
      }
      @keyframes glitch-anim-2 {
        0% {
          clip: rect(60px, 9999px, 70px, 0);
        }
        20% {
          clip: rect(10px, 9999px, 30px, 0);
        }
        40% {
          clip: rect(80px, 9999px, 20px, 0);
        }
        60% {
          clip: rect(40px, 9999px, 90px, 0);
        }
        80% {
          clip: rect(50px, 9999px, 10px, 0);
        }
        100% {
          clip: rect(20px, 9999px, 50px, 0);
        }
      }

      /* --- DEMO 2: PARTICLE SPHERE --- */
      #demo-sphere {
        background: radial-gradient(circle at center, #111 0%, #000 100%);
        perspective: 1000px;
      }
      canvas#orbCanvas {
        cursor: move;
        max-width: 100%;
      }
      .instruction {
        position: absolute;
        bottom: 20px;
        color: #666;
        font-family: var(--font-mono);
        font-size: 0.8rem;
        pointer-events: none;
      }

      /* --- DEMO 3: FUTURISTIC CARDS --- */
      #demo-cards {
        background: linear-gradient(to bottom, #050505, #0f0f15);
        perspective: 2000px;
      }

      .cards-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 2rem;
        width: 100%;
        max-width: 1200px;
        padding: 2rem;
      }

      .card {
        position: relative;
        height: 400px;
        background: var(--card-glass);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        transition:
          transform 0.4s ease,
          box-shadow 0.4s ease;
        transform-style: preserve-3d;
        overflow: hidden;
        cursor: pointer;
      }

      /* Scroll Reveal State (JS will toggle this) */
      .card.hidden {
        opacity: 0;
        transform: translateY(100px) rotateX(10deg);
      }
      .card.visible {
        opacity: 1;
        transform: translateY(0) rotateX(0);
      }

      .card:hover {
        transform: translateY(-10px) scale(1.02);
        box-shadow:
          0 20px 40px rgba(0, 0, 0, 0.5),
          0 0 20px var(--primary-dim);
        border-color: var(--primary-glow);
      }

      .card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1) 0%,
          transparent 100%
        );
        z-index: -1;
      }

      .card-content {
        transform: translateZ(20px); /* Parallax depth */
        z-index: 2;
      }

      .card h3 {
        font-family: var(--font-mono);
        margin-bottom: 0.5rem;
        color: var(--primary);
      }

      .card p {
        font-size: 0.9rem;
        color: #aaa;
        line-height: 1.5;
      }

      .card-decoration {
        position: absolute;
        top: -50px;
        right: -50px;
        width: 150px;
        height: 150px;
        background: var(--primary);
        filter: blur(80px);
        opacity: 0.4;
        transition: opacity 0.3s;
      }
      .card:hover .card-decoration {
        opacity: 0.8;
      }

      /* --- DEMO 4: MATRIX & THEME --- */
      #demo-matrix {
        position: relative;
      }
      canvas#matrixCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .matrix-ui {
        z-index: 10;
        background: rgba(0, 0, 0, 0.8);
        padding: 2rem;
        border: 1px solid var(--primary);
        border-radius: 8px;
        backdrop-filter: blur(5px);
        text-align: center;
      }

      .theme-switcher {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
      }

      .theme-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 2px solid #333;
        cursor: pointer;
        transition:
          transform 0.2s,
          border-color 0.2s;
      }
      .theme-btn:hover,
      .theme-btn.active {
        transform: scale(1.1);
        border-color: #fff;
      }
    </style>
  </head>
  <body>
    <section id="demo-hud">
      <h2>System Override</h2>
      <div class="hud-container">
        <div class="scan-line"></div>
        <div class="glitch-text" data-text="ACCESS GRANTED">ACCESS GRANTED</div>
        <div class="hud-stats">
          <span>CPU: <span id="cpu-val">34</span>%</span>
          <span>MEM: <span id="mem-val">12</span>TB</span>
          <span>NET: SECURE</span>
        </div>
        <p style="margin-top: 1rem; color: #888; font-family: var(--font-mono)">
          > Initializing protocol v.9.0<br />
          > Decrypting secure keys...<br />
          > Uplink established.
        </p>
      </div>
    </section>

    <section id="demo-sphere">
      <h2>Neural Core</h2>
      <canvas id="orbCanvas"></canvas>
      <div class="instruction">[ DRAG TO ROTATE ]</div>
    </section>

    <section id="demo-cards">
      <h2>Data Archives</h2>
      <div class="cards-grid">
        <div class="card hidden">
          <div class="card-decoration"></div>
          <div class="card-content">
            <h3>Project Alpha</h3>
            <p>
              Advanced neural network integration with synaptic feedback loops.
            </p>
          </div>
        </div>
        <div class="card hidden">
          <div class="card-decoration"></div>
          <div class="card-content">
            <h3>Neon Protocol</h3>
            <p>
              High-bandwidth optical data transfer across decentralized nodes.
            </p>
          </div>
        </div>
        <div class="card hidden">
          <div class="card-decoration"></div>
          <div class="card-content">
            <h3>Void Sector</h3>
            <p>
              Classified anomalous data storage. Clearance Level 5 required.
            </p>
          </div>
        </div>
      </div>
    </section>

    <section id="demo-matrix">
      <canvas id="matrixCanvas"></canvas>
      <div class="matrix-ui">
        <h2>System Theme</h2>
        <p style="font-family: var(--font-mono); color: #aaa">
          Select Interface Color:
        </p>
        <div class="theme-switcher">
          <button
            class="theme-btn"
            style="background: #00ffff"
            onclick="setTheme(180, this)"
            aria-label="Cyan"
          ></button>
          <button
            class="theme-btn"
            style="background: #ff0055"
            onclick="setTheme(340, this)"
            aria-label="Pink"
          ></button>
          <button
            class="theme-btn"
            style="background: #00ff44"
            onclick="setTheme(120, this)"
            aria-label="Green"
          ></button>
        </div>
      </div>
    </section>

    <script>
      // --- SHARED UTILS ---
      const getVar = (name) =>
        getComputedStyle(document.documentElement)
          .getPropertyValue(name)
          .trim();

      // --- 1. HUD ANIMATION LOGIC ---
      function updateHudStats() {
        document.getElementById("cpu-val").innerText =
          Math.floor(Math.random() * 30) + 20;
        document.getElementById("mem-val").innerText =
          Math.floor(Math.random() * 50) + 10;
      }
      setInterval(updateHudStats, 2000);

      // --- 2. 3D PARTICLE SPHERE (Vanilla JS Canvas) ---
      const orbCanvas = document.getElementById("orbCanvas");
      const orbCtx = orbCanvas.getContext("2d");
      let width, height;
      let particles = [];
      const particleCount = 600;
      const globeRadius = 150;

      // Rotation state
      let rotX = 0;
      let rotY = 0;
      let targetRotX = 0;
      let targetRotY = 0;
      let isDragging = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      function initOrb() {
        width = window.innerWidth;
        height = window.innerHeight; // Full section height handled by CSS, but canvas needs explicit dim
        orbCanvas.width = width;
        orbCanvas.height = 600; // Fixed height within section

        particles = [];
        for (let i = 0; i < particleCount; i++) {
          // Spherical Distribution (Fibonacci Sphere algorithm for even spacing)
          const phi = Math.acos(-1 + (2 * i) / particleCount);
          const theta = Math.sqrt(particleCount * Math.PI) * phi;

          particles.push({
            x: globeRadius * Math.cos(theta) * Math.sin(phi),
            y: globeRadius * Math.sin(theta) * Math.sin(phi),
            z: globeRadius * Math.cos(phi),
            size: Math.random() * 2 + 1,
          });
        }
      }

      // 3D Rotation Math
      function rotate3D(x, y, z, angleX, angleY) {
        // Rotate around Y
        let cosY = Math.cos(angleY);
        let sinY = Math.sin(angleY);
        let x1 = x * cosY - z * sinY;
        let z1 = z * cosY + x * sinY;

        // Rotate around X
        let cosX = Math.cos(angleX);
        let sinX = Math.sin(angleX);
        let y2 = y * cosX - z1 * sinX;
        let z2 = z1 * cosX + y * sinX;

        return { x: x1, y: y2, z: z2 };
      }

      function drawOrb() {
        // Clear
        orbCtx.fillStyle = "rgba(5, 5, 5, 0.3)"; // Trails
        orbCtx.fillRect(0, 0, orbCanvas.width, orbCanvas.height);

        const cx = orbCanvas.width / 2;
        const cy = orbCanvas.height / 2;
        const primaryColor = getVar("--primary");

        // Smooth rotation interpolation
        rotX += (targetRotX - rotX) * 0.05;
        rotY += (targetRotY - rotY) * 0.05;

        // Auto rotate slightly if not dragging
        if (!isDragging) targetRotY += 0.002;

        particles.forEach((p) => {
          const r = rotate3D(p.x, p.y, p.z, rotX, rotY);

          // Simple perspective projection
          const scale = 300 / (300 + r.z); // FOV = 300
          const px = cx + r.x * scale;
          const py = cy + r.y * scale;

          // Draw based on Z-depth
          if (r.z < 150) {
            // Culling
            const alpha = scale - 0.5; // Fade distant particles
            orbCtx.fillStyle = primaryColor;
            orbCtx.globalAlpha = Math.max(0.1, alpha);
            orbCtx.beginPath();
            orbCtx.arc(px, py, p.size * scale, 0, Math.PI * 2);
            orbCtx.fill();

            // Connect lines for "tech" feel if close
            particles.forEach((p2) => {
              // This is expensive O(N^2), so we just check a few or simulate structure
              // For performance in this demo, we skip lines or do very simple check
            });
          }
        });
        orbCtx.globalAlpha = 1;
        requestAnimationFrame(drawOrb);
      }

      // Mouse Events for Orb
      orbCanvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      });
      orbCanvas.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        targetRotY += dx * 0.01;
        targetRotX += dy * 0.01;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      });
      window.addEventListener("mouseup", () => (isDragging = false));

      // Touch events
      orbCanvas.addEventListener("touchstart", (e) => {
        isDragging = true;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
      });
      orbCanvas.addEventListener("touchmove", (e) => {
        if (!isDragging) return;
        const dx = e.touches[0].clientX - lastMouseX;
        const dy = e.touches[0].clientY - lastMouseY;
        targetRotY += dx * 0.01;
        targetRotX += dy * 0.01;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
      });

      // --- 3. CARD SCROLL REVEAL (Intersection Observer) ---
      const observerOptions = { threshold: 0.2 };
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.remove("hidden");
            entry.target.classList.add("visible");
          }
        });
      }, observerOptions);

      document
        .querySelectorAll(".card")
        .forEach((card) => observer.observe(card));

      // Glassmorphism Tilt Effect
      document.querySelectorAll(".card").forEach((card) => {
        card.addEventListener("mousemove", (e) => {
          const rect = card.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          // Calculate rotation (center is 0)
          const xPct = x / rect.width - 0.5;
          const yPct = y / rect.height - 0.5;

          // Rotate slightly opposite to mouse movement for 3D feel
          card.style.transform = `perspective(1000px) rotateY(${xPct * 10}deg) rotateX(${-yPct * 10}deg) scale(1.02)`;
        });

        card.addEventListener("mouseleave", () => {
          card.style.transform = "translateY(0) rotateX(0)";
        });
      });

      // --- 4. MATRIX RAIN & THEME SWITCHER ---
      const matrixCanvas = document.getElementById("matrixCanvas");
      const mCtx = matrixCanvas.getContext("2d");

      function resizeMatrix() {
        matrixCanvas.width = window.innerWidth;
        matrixCanvas.height =
          document.getElementById("demo-matrix").clientHeight;
      }

      const katakana =
        "アァカサタナハマヤャラワガザダバパイィキシチニヒミリヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレゲゼデベペオォコソトノホモヨョロヲゴゾドボポ1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const chars = katakana.split("");
      const fontSize = 16;
      let columns;
      let drops = [];

      function initMatrix() {
        resizeMatrix();
        columns = matrixCanvas.width / fontSize;
        drops = [];
        for (let x = 0; x < columns; x++) drops[x] = 1;
      }

      function drawMatrix() {
        // Black bg with slight opacity for trail effect
        mCtx.fillStyle = "rgba(5, 5, 5, 0.05)";
        mCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

        mCtx.fillStyle = getVar("--primary");
        mCtx.font = fontSize + "px monospace";

        for (let i = 0; i < drops.length; i++) {
          const text = chars[Math.floor(Math.random() * chars.length)];
          mCtx.fillText(text, i * fontSize, drops[i] * fontSize);

          if (
            drops[i] * fontSize > matrixCanvas.height &&
            Math.random() > 0.975
          ) {
            drops[i] = 0;
          }
          drops[i]++;
        }
        requestAnimationFrame(drawMatrix);
      }

      // Theme Logic
      function setTheme(hue, btnElement = null) {
        document.documentElement.style.setProperty("--hue", hue);
        localStorage.setItem("cyber_hue", hue);

        // Update active button state
        document
          .querySelectorAll(".theme-btn")
          .forEach((btn) => btn.classList.remove("active"));
        if (btnElement) btnElement.classList.add("active");
      }

      // Init All
      window.addEventListener("load", () => {
        // Load saved theme
        const savedHue = localStorage.getItem("cyber_hue");
        if (savedHue) setTheme(savedHue);

        // Init Demos
        initOrb();
        drawOrb();
        initMatrix();
        drawMatrix();
      });

      window.addEventListener("resize", () => {
        initOrb();
        initMatrix();
      });
    </script>
  </body>
</html>
